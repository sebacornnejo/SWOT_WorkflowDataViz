<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>SWOT L3 Workflow - Final Master</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@500;700;800&display=swap');

        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #f0f2f5; 
            font-family: 'Montserrat', sans-serif; 
        }
        
        #connector-svg {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 0;
        }
        
        #labels-container {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .label-box {
            position: absolute;
            background: #ffffff;
            padding: 10px 14px;
            border-radius: 6px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            width: 210px;
            font-size: 12px;
            color: #333;
            border-left: 4px solid #333;
            transition: top 0.2s, left 0.2s;
        }

        .label-box h3 { 
            margin: 0 0 5px 0; font-size: 13px; font-weight: 800; 
            text-transform: uppercase; letter-spacing: -0.3px;
        }
        .label-box p { margin: 0; line-height: 1.3; color: #666; font-weight: 500; }
        .label-box .note { 
            display: block; margin-top: 6px; font-size: 10px; 
            font-weight: 700; padding-top: 4px; border-top: 1px solid #eee;
        }

        /* Border Colors matching Nodes */
        #lbl-ocean { border-color: #4cc9f0; }
        #lbl-ground { border-color: #333; }
        #lbl-atmo { border-color: #f72585; }
        #lbl-geo { border-color: #ff6b6b; }
        #lbl-geo .note { color: #e63946; }
        #lbl-nadir { border-color: #7209b7; }
        #lbl-karin { border-color: #4361ee; }
        #lbl-karin .note { color: #4361ee; }

    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>

    <svg id="connector-svg"></svg>

    <div id="labels-container">
        <div id="lbl-ocean" class="label-box">
            <h3>1. Interacción</h3>
            <p>Retrodispersión en sup. Dependencia de SWH y sigma0.</p>
        </div>
        <div id="lbl-ground" class="label-box">
            <h3>Recepción</h3>
            <p>Estación Terrena & Proc. L0/L1.</p>
        </div>
        <div id="lbl-atmo" class="label-box">
            <h3>2. Atmósfera</h3>
            <p>Corrección de Ionosfera, Vapor de Agua y Tropo. Seca.</p>
        </div>
        <div id="lbl-geo" class="label-box">
            <h3>3. Geofísica</h3>
            <p>Mareas (FES2022b) + DAC.</p>
            <span class="note">Crítico: Plataforma Arg.</span>
        </div>
        <div id="lbl-nadir" class="label-box">
            <h3>NADIR (1D)</h3>
            <p>Altimetría clásica. Referencia de calibración.</p>
            <span class="note">Salida: Serie Espacial 1D</span>
        </div>
        <div id="lbl-karin" class="label-box">
            <h3>4. KaRIn (SWOT)</h3>
            <p>Fusión L3. Calibración Roll/Fase.</p>
            <span class="note">Salida: Campo 2D</span>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // --- SCENE ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f2f5);

        const d = 48; 
        const aspect = window.innerWidth / window.innerHeight;
        const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
        camera.position.set(100, 100, 100); 
        camera.lookAt(0, 0, 0); 

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- LIGHTS ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
        dirLight.position.set(60, 100, 40);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // --- MATERIALS ---
        const matOcean = new THREE.MeshPhongMaterial({ color: 0x4cc9f0, shininess: 80, transparent: true, opacity: 0.9 });
        const matWhite = new THREE.MeshLambertMaterial({ color: 0xffffff });
        const matDark = new THREE.MeshLambertMaterial({ color: 0x2c3e50 });
        const matGrey = new THREE.MeshLambertMaterial({ color: 0x999999 });
        
        // --- 1. OCEAN & SAT ---
        const oceanGroup = new THREE.Group();
        oceanGroup.position.set(-45, -10, 35);
        scene.add(oceanGroup);
        
        // Water Block
        const oceanGeo = new THREE.BoxGeometry(18, 4, 18, 32, 1, 32);
        const ocean = new THREE.Mesh(oceanGeo, matOcean);
        ocean.receiveShadow = true;
        oceanGroup.add(ocean);

        // SIGNAL FOOTPRINTS (Interaction on water)
        const footprintMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 });
        
        // Nadir Footprint (Dot)
        const footNadir = new THREE.Mesh(new THREE.CircleGeometry(0.8, 16), footprintMat);
        footNadir.rotation.x = -Math.PI/2;
        footNadir.position.set(0, 2.1, 0);
        oceanGroup.add(footNadir);

        // KaRIn Footprints (Strips)
        const footL = new THREE.Mesh(new THREE.PlaneGeometry(3, 14), footprintMat);
        footL.rotation.x = -Math.PI/2;
        footL.position.set(5, 2.1, 0);
        oceanGroup.add(footL);

        const footR = new THREE.Mesh(new THREE.PlaneGeometry(3, 14), footprintMat);
        footR.rotation.x = -Math.PI/2;
        footR.position.set(-5, 2.1, 0);
        oceanGroup.add(footR);


        // Satellite
        const satGroup = new THREE.Group();
        satGroup.position.set(-45, 25, 35);
        satGroup.add(new THREE.Mesh(new THREE.BoxGeometry(3, 3, 6), matDark));
        satGroup.add(new THREE.Mesh(new THREE.BoxGeometry(14, 0.2, 3), new THREE.MeshLambertMaterial({color: 0x1a2b3c})));
        satGroup.add(new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 14), matWhite)); // Boom
        const antL = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.5, 1.2), matWhite); antL.position.z = 7; satGroup.add(antL);
        const antR = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.5, 1.2), matWhite); antR.position.z = -7; satGroup.add(antR);
        scene.add(satGroup);

        // Beams
        const beamMat = new THREE.MeshBasicMaterial({ color: 0x4cc9f0, transparent: true, opacity: 0.15, side: THREE.DoubleSide, depthWrite: false });
        
        const coneGeo = new THREE.ConeGeometry(1, 35, 32, 1, true);
        coneGeo.translate(0, -17.5, 0);
        const beamNadir = new THREE.Mesh(coneGeo, beamMat);
        beamNadir.position.copy(satGroup.position);
        scene.add(beamNadir);

        const swathShape = new THREE.Shape();
        swathShape.moveTo(0, 0); swathShape.lineTo(1.5, -35); swathShape.lineTo(-1.5, -35); swathShape.lineTo(0, 0);
        const swathGeo = new THREE.ExtrudeGeometry(swathShape, { depth: 3, bevelEnabled: false });
        swathGeo.translate(0, 0, -1.5);

        const beamL = new THREE.Mesh(swathGeo, beamMat);
        beamL.position.set(-45, 25, 42); beamL.rotation.x = 0.12;
        const beamR = new THREE.Mesh(swathGeo, beamMat);
        beamR.position.set(-45, 25, 28); beamR.rotation.x = -0.12;
        scene.add(beamL, beamR);


        // --- 2. GROUND STATION & COMPUTER ---
        const posGround = new THREE.Vector3(-30, 0, 20);
        
        // Dish
        const server = new THREE.Mesh(new THREE.BoxGeometry(3, 5, 3), matDark);
        server.position.copy(posGround);
        server.castShadow = true;
        scene.add(server);
        const dish = new THREE.Mesh(new THREE.SphereGeometry(2,16,16,0,Math.PI*2,0,Math.PI*0.5), matWhite);
        dish.position.copy(posGround).add(new THREE.Vector3(0,2.5,0));
        scene.add(dish);

        // COMPUTER (New Request)
        const compGroup = new THREE.Group();
        compGroup.position.copy(posGround).add(new THREE.Vector3(5, -1.5, 0));
        // Monitor
        const monitor = new THREE.Mesh(new THREE.BoxGeometry(0.2, 2, 3), matDark);
        monitor.position.y = 1.5;
        // Screen
        const screen = new THREE.Mesh(new THREE.PlaneGeometry(2.8, 1.8), new THREE.MeshBasicMaterial({color: 0x4cc9f0}));
        screen.rotation.y = -Math.PI/2; screen.position.set(-0.11, 1.5, 0);
        // Stand
        const stand = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 1), matGrey);
        stand.position.y = 0.25;
        // Tower
        const tower = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3, 4), matDark);
        tower.position.set(2, 1.5, 0);

        compGroup.add(monitor, screen, stand, tower);
        compGroup.rotation.y = -0.5; // Angle towards camera
        scene.add(compGroup);


        // --- 3. NODES WITH DECORATIONS ---
        function createNode(pos, color, name) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(6, 3, 6), new THREE.MeshLambertMaterial({color:color}));
            mesh.position.copy(pos);
            mesh.castShadow = true; mesh.receiveShadow = true; mesh.name = name;
            scene.add(mesh);
            return mesh;
        }

        // Atmosfera (Particles)
        const posAtmo = new THREE.Vector3(-15, 0, 5);
        const nodeAtmo = createNode(posAtmo, 0xf72585, 'node-atmo');
        
        const particles = new THREE.Group();
        const pGeo = new THREE.SphereGeometry(0.4);
        const pMat = new THREE.MeshBasicMaterial({color: 0xffffff, transparent:true, opacity:0.6});
        for(let i=0; i<8; i++){
            const p = new THREE.Mesh(pGeo, pMat);
            p.position.set(Math.random()*6-3, Math.random()*4+1, Math.random()*6-3);
            particles.add(p);
        }
        nodeAtmo.add(particles); // Child of node

        // Geofisica (Tide Ring)
        const posGeo = new THREE.Vector3(5, 0, -10);
        const nodeGeo = createNode(posGeo, 0xff6b6b, 'node-geo');
        
        const tideRing = new THREE.Mesh(
            new THREE.TorusGeometry(5, 0.3, 8, 32), 
            new THREE.MeshBasicMaterial({color: 0xffffff, transparent:true, opacity:0.5})
        );
        tideRing.rotation.x = Math.PI/2;
        nodeGeo.add(tideRing);

        // Split
        const posSplit = new THREE.Vector3(20, 0, -25);

        // Nadir
        const posNadir = new THREE.Vector3(25, 15, -45);
        const nodeNadir = createNode(posNadir, 0x7209b7, 'node-nadir');
        nodeNadir.scale.setScalar(0.7);

        // KaRIn
        const posKaRIn = new THREE.Vector3(45, 0, -15);
        const nodeKaRIn = createNode(posKaRIn, 0x4361ee, 'node-karin');
        nodeKaRIn.scale.set(1.5, 1.2, 1.5);


        // --- 4. OUTPUTS ---

        // 2D KaRIn Field
        const out2DGroup = new THREE.Group();
        out2DGroup.position.copy(posKaRIn).add(new THREE.Vector3(15, -8, 15));
        scene.add(out2DGroup);
        const sshaGeo = new THREE.PlaneGeometry(14, 14, 24, 24);
        sshaGeo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(sshaGeo.attributes.position.count * 3), 3));
        const sshaMat = new THREE.MeshBasicMaterial({ vertexColors: true, wireframe: true });
        const sshaMesh = new THREE.Mesh(sshaGeo, sshaMat);
        sshaMesh.rotation.x = -Math.PI/2;
        out2DGroup.add(sshaMesh);

        // 1D Nadir Series (COLORED)
        const out1DGroup = new THREE.Group();
        out1DGroup.position.copy(posNadir).add(new THREE.Vector3(12, -2, 0));
        scene.add(out1DGroup);
        
        const lineRes = 60;
        const linePoints = [];
        const lineColors = [];
        for(let i=0; i<lineRes; i++) {
            linePoints.push(0, 0, 0);
            lineColors.push(1,1,1);
        }
        const lineGeo = new THREE.BufferGeometry();
        lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(linePoints, 3));
        lineGeo.setAttribute('color', new THREE.Float32BufferAttribute(lineColors, 3));
        
        const lineMat = new THREE.LineBasicMaterial({ vertexColors: true, linewidth: 2 });
        const lineMesh = new THREE.Line(lineGeo, lineMat);
        out1DGroup.add(lineMesh);
        
        // Small grid for 1D
        const grid1D = new THREE.GridHelper(18, 10, 0xcccccc, 0xeeeeee);
        grid1D.position.set(9, -2, 0); grid1D.scale.z = 0.2;
        out1DGroup.add(grid1D);


        // --- 5. PIPES ---
        function createPipe(p1, p2, color=0xbbbbbb) {
            const path = new THREE.LineCurve3(p1, p2);
            const mesh = new THREE.Mesh(new THREE.TubeGeometry(path, 1, 0.3, 8, false), new THREE.MeshBasicMaterial({color}));
            scene.add(mesh);
            return path;
        }
        createPipe(posGround, posAtmo);
        createPipe(posAtmo, posGeo);
        createPipe(posGeo, posSplit);
        createPipe(posSplit, new THREE.Vector3(25, 8, -35), 0x999999);
        createPipe(new THREE.Vector3(25, 8, -35), posNadir, 0x999999);
        createPipe(posSplit, posKaRIn, 0x4361ee);


        // --- ANIMATION & LOGIC ---
        const packets = [];
        function spawnPacket(start, end, type) {
            const color = type==='nadir'?0x999999:0x4cc9f0;
            const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.6), new THREE.MeshBasicMaterial({color}));
            scene.add(mesh);
            return { mesh, start, end, alpha: 0, speed: 1.2, type };
        }

        const clock = new THREE.Clock();
        let timer = 0;

        // UPDATED LABEL OFFSETS TO PREVENT BLOCKING
        const labelsConfig = [
            { id: 'lbl-ocean', obj: oceanGroup, offset: {x: -140, y: 100} }, // Up & Left
            { id: 'lbl-ground', obj: server, offset: {x: -80, y: -100} }, // Down
            { id: 'lbl-atmo', obj: nodeAtmo, offset: {x: -20, y: -100} }, // Down, shifted
            { id: 'lbl-geo', obj: nodeGeo, offset: {x: 0, y: 130} }, // Way Up
            { id: 'lbl-nadir', obj: nodeNadir, offset: {x: 120, y: 60} }, // Right & Up to clear line
            { id: 'lbl-karin', obj: nodeKaRIn, offset: {x: 0, y: 140} } // Up
        ];

        function updateLabels() {
            const svg = document.getElementById('connector-svg');
            while(svg.firstChild) svg.removeChild(svg.firstChild);

            labelsConfig.forEach(conf => {
                const el = document.getElementById(conf.id);
                if(!el) return;
                const v = conf.obj.position.clone();
                if(conf.id === 'lbl-ocean') v.y += 2;
                v.project(camera);
                const cx = (v.x * .5 + .5) * window.innerWidth;
                const cy = (v.y * -.5 + .5) * window.innerHeight;
                const lx = cx + conf.offset.x;
                const ly = cy - conf.offset.y;
                el.style.left = `${lx}px`; el.style.top = `${ly}px`;

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', cx); line.setAttribute('y1', cy);
                line.setAttribute('x2', lx + (conf.offset.x > 0 ? 0 : 200)); 
                line.setAttribute('y2', ly + 20); 
                line.setAttribute('stroke', '#bbb'); line.setAttribute('stroke-width', '1.5');
                svg.appendChild(line);
                
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', cx); circle.setAttribute('cy', cy);
                circle.setAttribute('r', '3'); circle.setAttribute('fill', '#333');
                svg.appendChild(circle);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // 1. OCEAN
            const pos = oceanGeo.attributes.position;
            for(let i=0; i<pos.count; i++){
                if(pos.getY(i) > 1) {
                    const x = pos.getX(i);
                    const z = pos.getZ(i);
                    pos.setY(i, 2 + Math.sin(x*0.4 + time*1.5) * Math.cos(z*0.4 + time) * 0.5);
                }
            }
            oceanGeo.attributes.position.needsUpdate = true;

            // Footprint pulsing
            footNadir.scale.setScalar(1 + Math.sin(time*10)*0.1);
            footL.material.opacity = 0.3 + Math.sin(time*5)*0.2;

            // 2. DECORATIONS
            // Atmo Particles rotate
            particles.rotation.y = time * 0.5;
            // Tide Ring bobbing
            tideRing.position.y = Math.sin(time * 2) * 1.5;

            // 3. OUTPUTS
            // 2D Field
            const sPos = sshaGeo.attributes.position;
            const sCol = sshaGeo.attributes.color;
            const _col = new THREE.Color();
            for(let i=0; i<sPos.count; i++){
                const x = sPos.getX(i); const y = sPos.getY(i);
                const val = Math.sin(x*0.5 + time) * Math.cos(y*0.5 + time*0.5) * 2;
                sPos.setZ(i, val);
                if(val<0) _col.setHex(0x0077be).lerp(new THREE.Color(0xffffff), 1-Math.abs(val/2));
                else _col.setHex(0xffffff).lerp(new THREE.Color(0xd00000), val/2);
                sCol.setXYZ(i, _col.r, _col.g, _col.b);
            }
            sshaGeo.attributes.position.needsUpdate = true;
            sshaGeo.attributes.color.needsUpdate = true;

            // 1D Series (Now Colored!)
            const lPos = lineGeo.attributes.position;
            const lCol = lineGeo.attributes.color;
            for(let i=0; i<lineRes; i++){
                const x = i * 0.3;
                const val = Math.sin(x + time * 2) * 1.5 + (Math.random()*0.2);
                lPos.setXYZ(i, x, val, 0);
                
                // Color logic same as 2D
                if(val<0) _col.setHex(0x0077be).lerp(new THREE.Color(0xffffff), 1-Math.abs(val/2));
                else _col.setHex(0xffffff).lerp(new THREE.Color(0xd00000), val/2);
                lCol.setXYZ(i, _col.r, _col.g, _col.b);
            }
            lineGeo.attributes.position.needsUpdate = true;
            lineGeo.attributes.color.needsUpdate = true;

            // 4. PACKETS
            timer += delta;
            if(timer > 1.8) {
                packets.push(spawnPacket(new THREE.Vector3(-45, 0, 35), satGroup.position, 'up'));
                timer = 0;
            }
            for(let i=packets.length-1; i>=0; i--){
                let p = packets[i]; p.alpha += p.speed * delta;
                if(p.alpha >= 1) {
                    const m = p.mesh;
                    if(p.type==='up'){ packets[i]=spawnPacket(satGroup.position, posGround, 'down'); packets[i].mesh=m; }
                    else if(p.type==='down'){ packets[i]=spawnPacket(posGround, posAtmo, 'atmo'); packets[i].mesh=m; }
                    else if(p.type==='atmo'){ packets[i]=spawnPacket(posAtmo, posGeo, 'geo'); packets[i].mesh=m; }
                    else if(p.type==='geo'){ 
                        packets[i]=spawnPacket(posGeo, posSplit, 'split'); packets[i].mesh=m; 
                        // Pulse ring
                        tideRing.scale.setScalar(1.2); setTimeout(()=>tideRing.scale.setScalar(1),200);
                    }
                    else if(p.type==='split'){
                        if(Math.random()>0.7){ packets[i]=spawnPacket(posSplit, posNadir, 'nadir'); packets[i].mesh=m; m.material=new THREE.MeshBasicMaterial({color:0x999999}); m.scale.setScalar(0.6); }
                        else { packets[i]=spawnPacket(posSplit, posKaRIn, 'karin'); packets[i].mesh=m; }
                    }
                    else if(p.type==='karin'){ packets[i]=spawnPacket(posKaRIn, out2DGroup.position, 'end'); packets[i].mesh=m; }
                    else if(p.type==='nadir'){ packets[i]=spawnPacket(posNadir, out1DGroup.position, 'end'); packets[i].mesh=m; }
                    else { scene.remove(m); packets.splice(i,1); }
                } else { p.mesh.position.lerpVectors(p.start, p.end, p.alpha); }
            }

            updateLabels();
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -d * aspect; camera.right = d * aspect;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateLabels();
        });

    </script>
</body>
</html>
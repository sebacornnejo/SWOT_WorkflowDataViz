<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <title>SWOT L3 Workflow - Academic Corporate Memphis</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #F9F9F9;
            /* Clean Off-White */
            font-family: 'Inter', sans-serif;
        }

        #connector-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
        }

        #labels-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .label-box {
            position: absolute;
            background: #ffffff;
            padding: 12px 16px;
            border-radius: 12px;
            /* Softer corners */
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.06);
            /* Softer shadow */
            width: 220px;
            font-size: 13px;
            color: #2D3436;
            border-left: 6px solid #333;
            transition: top 0.2s, left 0.2s;
        }

        .label-box h3 {
            margin: 0 0 6px 0;
            font-size: 14px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .label-box p {
            margin: 0;
            line-height: 1.4;
            color: #636E72;
            font-weight: 400;
        }

        .label-box .note {
            display: block;
            margin-top: 8px;
            font-size: 11px;
            font-weight: 700;
            padding-top: 6px;
            border-top: 1px solid #F0F0F0;
        }

        /* Border Colors matching Nodes (New Palette) */
        #lbl-ocean {
            border-color: #5FA8D3;
        }

        #lbl-ground {
            border-color: #1B4965;
        }

        #lbl-atmo {
            border-color: #EF476F;
        }

        #lbl-geo {
            border-color: #FFD166;
        }

        #lbl-geo .note {
            color: #E67E22;
        }

        #lbl-nadir {
            border-color: #06D6A0;
        }

        #lbl-karin {
            border-color: #118AB2;
        }

        #lbl-karin .note {
            color: #118AB2;
        }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>
</head>

<body>

    <svg id="connector-svg"></svg>

    <div id="labels-container">
        <div id="lbl-ocean" class="label-box">
            <h3>1. Interacción</h3>
            <p>Retrodispersión en sup. Dependencia de SWH y sigma0.</p>
        </div>
        <div id="lbl-ground" class="label-box">
            <h3>Recepción</h3>
            <p>Estación Terrena & Proc. L0/L1.</p>
        </div>
        <div id="lbl-atmo" class="label-box">
            <h3>2. Atmósfera</h3>
            <p>Corrección de Ionosfera, Vapor de Agua y Tropo. Seca.</p>
        </div>
        <div id="lbl-geo" class="label-box">
            <h3>3. Geofísica</h3>
            <p>Mareas (FES2022b) + DAC.</p>
            <span class="note">Crítico: Plataforma Arg.</span>
        </div>
        <div id="lbl-nadir" class="label-box">
            <h3>NADIR (1D)</h3>
            <p>Altimetría clásica. Referencia de calibración.</p>
            <span class="note">Salida: Serie Espacial 1D</span>
        </div>
        <div id="lbl-karin" class="label-box">
            <h3>4. KaRIn (SWOT)</h3>
            <p>Fusión L3. Calibración Roll/Fase.</p>
            <span class="note">Salida: Campo 2D</span>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // --- SCENE ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xF9F9F9); // Off-white

        const d = 48;
        const aspect = window.innerWidth / window.innerHeight;
        const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
        camera.position.set(100, 100, 100);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // --- LIGHTS ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
        dirLight.position.set(60, 100, 40);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // --- MATERIALS (Toon / Flat) ---
        // Helper to create outline
        function addOutline(mesh, color = 0x000000, thickness = 1) {
            const edges = new THREE.EdgesGeometry(mesh.geometry);
            const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: color }));
            mesh.add(line);
        }

        const matOcean = new THREE.MeshToonMaterial({ color: 0x5FA8D3, transparent: true, opacity: 0.9 });
        const matWhite = new THREE.MeshToonMaterial({ color: 0xffffff });
        const matDark = new THREE.MeshToonMaterial({ color: 0x2D3436 });
        const matGrey = new THREE.MeshToonMaterial({ color: 0xB2BEC3 });

        // --- 1. OCEAN & SAT ---
        const oceanGroup = new THREE.Group();
        oceanGroup.position.set(-45, -10, 35);
        scene.add(oceanGroup);

        // Water Block
        const oceanGeo = new THREE.BoxGeometry(18, 4, 18, 32, 1, 32);
        const ocean = new THREE.Mesh(oceanGeo, matOcean);
        ocean.receiveShadow = true;
        addOutline(ocean, 0x348ABD);
        oceanGroup.add(ocean);

        // SIGNAL FOOTPRINTS (Interaction on water)
        const footprintMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.6 });

        // Nadir Footprint (Dot)
        const footNadir = new THREE.Mesh(new THREE.CircleGeometry(0.8, 16), footprintMat);
        footNadir.rotation.x = -Math.PI / 2;
        footNadir.position.set(0, 2.1, 0);
        oceanGroup.add(footNadir);

        // KaRIn Footprints (Strips)
        const footL = new THREE.Mesh(new THREE.PlaneGeometry(3, 14), footprintMat);
        footL.rotation.x = -Math.PI / 2;
        footL.position.set(5, 2.1, 0);
        oceanGroup.add(footL);

        const footR = new THREE.Mesh(new THREE.PlaneGeometry(3, 14), footprintMat);
        footR.rotation.x = -Math.PI / 2;
        footR.position.set(-5, 2.1, 0);
        oceanGroup.add(footR);


        // Satellite
        const satGroup = new THREE.Group();
        satGroup.position.set(-45, 25, 35);

        const satBody = new THREE.Mesh(new THREE.BoxGeometry(3, 3, 6), matDark);
        addOutline(satBody, 0x000000);
        satGroup.add(satBody);

        const satWings = new THREE.Mesh(new THREE.BoxGeometry(14, 0.2, 3), new THREE.MeshToonMaterial({ color: 0x1B4965 }));
        addOutline(satWings, 0x000000);
        satGroup.add(satWings);

        const satBoom = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 14), matWhite);
        satGroup.add(satBoom);

        const antL = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.5, 1.2), matWhite); antL.position.z = 7; satGroup.add(antL);
        const antR = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.5, 1.2), matWhite); antR.position.z = -7; satGroup.add(antR);
        scene.add(satGroup);

        // Beams
        const beamMat = new THREE.MeshBasicMaterial({ color: 0x5FA8D3, transparent: true, opacity: 0.2, side: THREE.DoubleSide, depthWrite: false });

        const coneGeo = new THREE.ConeGeometry(1, 35, 32, 1, true);
        coneGeo.translate(0, -17.5, 0);
        const beamNadir = new THREE.Mesh(coneGeo, beamMat);
        beamNadir.position.copy(satGroup.position);
        scene.add(beamNadir);

        const swathShape = new THREE.Shape();
        swathShape.moveTo(0, 0); swathShape.lineTo(1.5, -35); swathShape.lineTo(-1.5, -35); swathShape.lineTo(0, 0);
        const swathGeo = new THREE.ExtrudeGeometry(swathShape, { depth: 3, bevelEnabled: false });
        swathGeo.translate(0, 0, -1.5);

        const beamL = new THREE.Mesh(swathGeo, beamMat);
        beamL.position.set(-45, 25, 42); beamL.rotation.x = 0.12;
        const beamR = new THREE.Mesh(swathGeo, beamMat);
        beamR.position.set(-45, 25, 28); beamR.rotation.x = -0.12;
        scene.add(beamL, beamR);


        // --- 2. GROUND STATION & COMPUTER ---
        const posGround = new THREE.Vector3(-30, 0, 20);

        // Dish
        const server = new THREE.Mesh(new THREE.BoxGeometry(3, 5, 3), matDark);
        server.position.copy(posGround);
        server.castShadow = true;
        addOutline(server, 0x000000);
        scene.add(server);

        const dish = new THREE.Mesh(new THREE.SphereGeometry(2, 16, 16, 0, Math.PI * 2, 0, Math.PI * 0.5), matWhite);
        dish.position.copy(posGround).add(new THREE.Vector3(0, 2.5, 0));
        addOutline(dish, 0x999999);
        scene.add(dish);

        // COMPUTER
        const compGroup = new THREE.Group();
        compGroup.position.copy(posGround).add(new THREE.Vector3(5, -1.5, 0));
        // Monitor
        const monitor = new THREE.Mesh(new THREE.BoxGeometry(0.2, 2, 3), matDark);
        monitor.position.y = 1.5;
        // Screen
        const screen = new THREE.Mesh(new THREE.PlaneGeometry(2.8, 1.8), new THREE.MeshBasicMaterial({ color: 0x5FA8D3 }));
        screen.rotation.y = -Math.PI / 2; screen.position.set(-0.11, 1.5, 0);
        // Stand
        const stand = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 1), matGrey);
        stand.position.y = 0.25;
        // Tower
        const tower = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3, 4), matDark);
        tower.position.set(2, 1.5, 0);

        compGroup.add(monitor, screen, stand, tower);
        compGroup.rotation.y = -0.5;
        scene.add(compGroup);


        // --- 3. NODES WITH DECORATIONS ---
        function createNode(pos, color, name) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(6, 3, 6), new THREE.MeshToonMaterial({ color: color }));
            mesh.position.copy(pos);
            mesh.castShadow = true; mesh.receiveShadow = true; mesh.name = name;
            addOutline(mesh, 0x000000, 2); // Stronger outline
            scene.add(mesh);
            return mesh;
        }

        // Atmosfera (Particles)
        const posAtmo = new THREE.Vector3(-15, 0, 5);
        const nodeAtmo = createNode(posAtmo, 0xEF476F, 'node-atmo'); // Vibrant Pink

        const particles = new THREE.Group();
        const pGeo = new THREE.SphereGeometry(0.4);
        const pMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
        for (let i = 0; i < 8; i++) {
            const p = new THREE.Mesh(pGeo, pMat);
            p.position.set(Math.random() * 6 - 3, Math.random() * 4 + 1, Math.random() * 6 - 3);
            particles.add(p);
        }
        nodeAtmo.add(particles);

        // Geofisica (Tide Ring)
        const posGeo = new THREE.Vector3(5, 0, -10);
        const nodeGeo = createNode(posGeo, 0xFFD166, 'node-geo'); // Mustard Yellow

        const tideRing = new THREE.Mesh(
            new THREE.TorusGeometry(5, 0.3, 8, 32),
            new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.6 })
        );
        tideRing.rotation.x = Math.PI / 2;
        nodeGeo.add(tideRing);

        // Split
        const posSplit = new THREE.Vector3(20, 0, -25);

        // Nadir
        const posNadir = new THREE.Vector3(25, 15, -45);
        const nodeNadir = createNode(posNadir, 0x06D6A0, 'node-nadir'); // Teal
        nodeNadir.scale.setScalar(0.7);

        // KaRIn
        const posKaRIn = new THREE.Vector3(45, 0, -15);
        const nodeKaRIn = createNode(posKaRIn, 0x118AB2, 'node-karin'); // Blue
        nodeKaRIn.scale.set(1.5, 1.2, 1.5);


        // --- 4. OUTPUTS ---

        // 2D KaRIn Field
        const out2DGroup = new THREE.Group();
        out2DGroup.position.copy(posKaRIn).add(new THREE.Vector3(15, -8, 15));
        scene.add(out2DGroup);
        const sshaGeo = new THREE.PlaneGeometry(14, 14, 24, 24);
        sshaGeo.setAttribute('color', new THREE.BufferAttribute(new Float32Array(sshaGeo.attributes.position.count * 3), 3));
        const sshaMat = new THREE.MeshBasicMaterial({ vertexColors: true, wireframe: true });
        const sshaMesh = new THREE.Mesh(sshaGeo, sshaMat);
        sshaMesh.rotation.x = -Math.PI / 2;
        out2DGroup.add(sshaMesh);

        // 1D Nadir Series (COLORED)
        const out1DGroup = new THREE.Group();
        out1DGroup.position.copy(posNadir).add(new THREE.Vector3(12, -2, 0));
        scene.add(out1DGroup);

        const lineRes = 60;
        const linePoints = [];
        const lineColors = [];
        for (let i = 0; i < lineRes; i++) {
            linePoints.push(0, 0, 0);
            lineColors.push(1, 1, 1);
        }
        const lineGeo = new THREE.BufferGeometry();
        lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(linePoints, 3));
        lineGeo.setAttribute('color', new THREE.Float32BufferAttribute(lineColors, 3));

        const lineMat = new THREE.LineBasicMaterial({ vertexColors: true, linewidth: 2 });
        const lineMesh = new THREE.Line(lineGeo, lineMat);
        out1DGroup.add(lineMesh);

        // Small grid for 1D
        const grid1D = new THREE.GridHelper(18, 10, 0xcccccc, 0xeeeeee);
        grid1D.position.set(9, -2, 0); grid1D.scale.z = 0.2;
        out1DGroup.add(grid1D);


        // --- 5. PIPES ---
        function createPipe(p1, p2, color = 0xBDC3C7) {
            const path = new THREE.LineCurve3(p1, p2);
            const mesh = new THREE.Mesh(new THREE.TubeGeometry(path, 1, 0.3, 8, false), new THREE.MeshToonMaterial({ color }));
            scene.add(mesh);
            return path;
        }
        createPipe(posGround, posAtmo);
        createPipe(posAtmo, posGeo);
        createPipe(posGeo, posSplit);
        createPipe(posSplit, new THREE.Vector3(25, 8, -35), 0xBDC3C7);
        createPipe(new THREE.Vector3(25, 8, -35), posNadir, 0xBDC3C7);
        createPipe(posSplit, posKaRIn, 0x118AB2);


        // --- ANIMATION & LOGIC ---
        const packets = [];
        function spawnPacket(start, end, type) {
            const color = type === 'nadir' ? 0x06D6A0 : 0x118AB2;
            const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.6), new THREE.MeshBasicMaterial({ color }));
            scene.add(mesh);
            return { mesh, start, end, alpha: 0, speed: 1.2, type };
        }

        const clock = new THREE.Clock();
        let timer = 0;

        // UPDATED LABEL OFFSETS TO PREVENT BLOCKING
        const labelsConfig = [
            { id: 'lbl-ocean', obj: oceanGroup, offset: { x: -220, y: 80 } }, // MOVED FAR LEFT
            { id: 'lbl-ground', obj: server, offset: { x: -80, y: -100 } },
            { id: 'lbl-atmo', obj: nodeAtmo, offset: { x: -20, y: -100 } },
            { id: 'lbl-geo', obj: nodeGeo, offset: { x: 0, y: 130 } },
            { id: 'lbl-nadir', obj: nodeNadir, offset: { x: 120, y: 60 } },
            { id: 'lbl-karin', obj: nodeKaRIn, offset: { x: 0, y: 140 } }
        ];

        function updateLabels() {
            const svg = document.getElementById('connector-svg');
            while (svg.firstChild) svg.removeChild(svg.firstChild);

            labelsConfig.forEach(conf => {
                const el = document.getElementById(conf.id);
                if (!el) return;
                const v = conf.obj.position.clone();
                if (conf.id === 'lbl-ocean') v.y += 2;
                v.project(camera);
                const cx = (v.x * .5 + .5) * window.innerWidth;
                const cy = (v.y * -.5 + .5) * window.innerHeight;
                const lx = cx + conf.offset.x;
                const ly = cy - conf.offset.y;
                el.style.left = `${lx}px`; el.style.top = `${ly}px`;

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', cx); line.setAttribute('y1', cy);
                line.setAttribute('x2', lx + (conf.offset.x > 0 ? 0 : 210)); // Adjusted for wider boxes
                line.setAttribute('y2', ly + 25);
                line.setAttribute('stroke', '#BDC3C7'); line.setAttribute('stroke-width', '1.5');
                line.setAttribute('stroke-dasharray', '4'); // Dashed line for academic feel
                svg.appendChild(line);

                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', cx); circle.setAttribute('cy', cy);
                circle.setAttribute('r', '4'); circle.setAttribute('fill', '#2D3436');
                svg.appendChild(circle);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // 1. OCEAN
            const pos = oceanGeo.attributes.position;
            for (let i = 0; i < pos.count; i++) {
                if (pos.getY(i) > 1) {
                    const x = pos.getX(i);
                    const z = pos.getZ(i);
                    pos.setY(i, 2 + Math.sin(x * 0.4 + time * 1.5) * Math.cos(z * 0.4 + time) * 0.5);
                }
            }
            oceanGeo.attributes.position.needsUpdate = true;

            // Footprint pulsing
            footNadir.scale.setScalar(1 + Math.sin(time * 10) * 0.1);
            footL.material.opacity = 0.3 + Math.sin(time * 5) * 0.2;

            // 2. DECORATIONS
            // Atmo Particles rotate
            particles.rotation.y = time * 0.5;
            // Tide Ring bobbing
            tideRing.position.y = Math.sin(time * 2) * 1.5;

            // 3. OUTPUTS
            // 2D Field
            const sPos = sshaGeo.attributes.position;
            const sCol = sshaGeo.attributes.color;
            const _col = new THREE.Color();
            for (let i = 0; i < sPos.count; i++) {
                const x = sPos.getX(i); const y = sPos.getY(i);
                const val = Math.sin(x * 0.5 + time) * Math.cos(y * 0.5 + time * 0.5) * 2;
                sPos.setZ(i, val);
                if (val < 0) _col.setHex(0x118AB2).lerp(new THREE.Color(0xffffff), 1 - Math.abs(val / 2));
                else _col.setHex(0xffffff).lerp(new THREE.Color(0xEF476F), val / 2);
                sCol.setXYZ(i, _col.r, _col.g, _col.b);
            }
            sshaGeo.attributes.position.needsUpdate = true;
            sshaGeo.attributes.color.needsUpdate = true;

            // 1D Series (Now Colored!)
            const lPos = lineGeo.attributes.position;
            const lCol = lineGeo.attributes.color;
            for (let i = 0; i < lineRes; i++) {
                const x = i * 0.3;
                const val = Math.sin(x + time * 2) * 1.5 + (Math.random() * 0.2);
                lPos.setXYZ(i, x, val, 0);

                // Color logic same as 2D
                if (val < 0) _col.setHex(0x118AB2).lerp(new THREE.Color(0xffffff), 1 - Math.abs(val / 2));
                else _col.setHex(0xffffff).lerp(new THREE.Color(0xEF476F), val / 2);
                lCol.setXYZ(i, _col.r, _col.g, _col.b);
            }
            lineGeo.attributes.position.needsUpdate = true;
            lineGeo.attributes.color.needsUpdate = true;

            // 4. PACKETS
            timer += delta;
            if (timer > 1.8) {
                packets.push(spawnPacket(new THREE.Vector3(-45, 0, 35), satGroup.position, 'up'));
                timer = 0;
            }
            for (let i = packets.length - 1; i >= 0; i--) {
                let p = packets[i]; p.alpha += p.speed * delta;
                if (p.alpha >= 1) {
                    const m = p.mesh;
                    if (p.type === 'up') { packets[i] = spawnPacket(satGroup.position, posGround, 'down'); packets[i].mesh = m; }
                    else if (p.type === 'down') { packets[i] = spawnPacket(posGround, posAtmo, 'atmo'); packets[i].mesh = m; }
                    else if (p.type === 'atmo') { packets[i] = spawnPacket(posAtmo, posGeo, 'geo'); packets[i].mesh = m; }
                    else if (p.type === 'geo') {
                        packets[i] = spawnPacket(posGeo, posSplit, 'split'); packets[i].mesh = m;
                        // Pulse ring
                        tideRing.scale.setScalar(1.2); setTimeout(() => tideRing.scale.setScalar(1), 200);
                    }
                    else if (p.type === 'split') {
                        if (Math.random() > 0.7) { packets[i] = spawnPacket(posSplit, posNadir, 'nadir'); packets[i].mesh = m; m.material = new THREE.MeshBasicMaterial({ color: 0x06D6A0 }); m.scale.setScalar(0.6); }
                        else { packets[i] = spawnPacket(posSplit, posKaRIn, 'karin'); packets[i].mesh = m; }
                    }
                    else if (p.type === 'karin') { packets[i] = spawnPacket(posKaRIn, out2DGroup.position, 'end'); packets[i].mesh = m; }
                    else if (p.type === 'nadir') { packets[i] = spawnPacket(posNadir, out1DGroup.position, 'end'); packets[i].mesh = m; }
                    else { scene.remove(m); packets.splice(i, 1); }
                } else { p.mesh.position.lerpVectors(p.start, p.end, p.alpha); }
            }

            updateLabels();
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener('resize', () => {
            const aspect = window.innerWidth / window.innerHeight;
            camera.left = -d * aspect; camera.right = d * aspect;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateLabels();
        });

    </script>
</body>

</html>